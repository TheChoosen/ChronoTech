/**
 * Debug Script pour analyser les probl√®mes Kanban
 * Diagnostique les conflits et probl√®mes d'initialisation
 */

class KanbanDebugger {
    constructor() {
        this.errors = [];
        this.warnings = [];
        this.info = [];
        
        this.runDiagnostics();
    }
    
    runDiagnostics() {
        console.log('üîç === D√âBUT DIAGNOSTIC KANBAN ===');
        
        this.checkGlobalVariables();
        this.checkDOMElements();
        this.checkEventListeners();
        this.checkCSRFToken();
        this.checkAPIEndpoints();
        this.checkDragDropSetup();
        
        this.displayResults();
    }
    
    checkGlobalVariables() {
        console.log('üìã V√©rification des variables globales...');
        
        // V√©rifier window.chronochat
        if (typeof window.chronochat === 'undefined') {
            this.errors.push('‚ùå window.chronochat n\'est pas d√©fini');
        } else {
            this.info.push('‚úÖ window.chronochat est d√©fini');
            
            // V√©rifier les m√©thodes essentielles
            const essentialMethods = ['handleDrop', 'allowDrop', 'updateWorkOrderStatus', 'loadKanbanData'];
            essentialMethods.forEach(method => {
                if (typeof window.chronochat[method] === 'function') {
                    this.info.push(`‚úÖ window.chronochat.${method}() existe`);
                } else {
                    this.errors.push(`‚ùå window.chronochat.${method}() manquant`);
                }
            });
        }
        
        // V√©rifier les fonctions globales
        const globalFunctions = ['allowDrop', 'handleDrop', 'createWorkOrder'];
        globalFunctions.forEach(func => {
            if (typeof window[func] === 'function') {
                this.info.push(`‚úÖ window.${func}() existe`);
            } else {
                this.errors.push(`‚ùå window.${func}() manquant`);
            }
        });
        
        // V√©rifier les classes
        if (typeof window.ChronoChatDashboard === 'function') {
            this.info.push('‚úÖ Classe ChronoChatDashboard disponible');
        } else {
            this.errors.push('‚ùå Classe ChronoChatDashboard manquante');
        }
    }
    
    checkDOMElements() {
        console.log('üèóÔ∏è V√©rification des √©l√©ments DOM...');
        
        // V√©rifier les colonnes Kanban (d'abord dans le modal, puis les versions standard)
        const columnIds = ['draft', 'pending', 'assigned', 'in_progress', 'completed', 'cancelled'];
        columnIds.forEach(id => {
            // Chercher d'abord dans le modal
            let column = document.getElementById(`modal-column-${id}`);
            let isModal = true;
            
            // Si pas trouv√© dans le modal, chercher version standard
            if (!column) {
                column = document.getElementById(`column-${id}`);
                isModal = false;
            }
            
            if (column) {
                const location = isModal ? 'modal' : 'page';
                this.info.push(`‚úÖ Colonne #${isModal ? 'modal-' : ''}column-${id} trouv√©e (${location})`);
                
                // V√©rifier les attributs drag-drop
                if (column.hasAttribute('ondrop')) {
                    this.info.push(`‚úÖ Attribut ondrop sur #${isModal ? 'modal-' : ''}column-${id}`);
                } else {
                    this.warnings.push(`‚ö†Ô∏è Attribut ondrop manquant sur #${isModal ? 'modal-' : ''}column-${id}`);
                }
                
                if (column.hasAttribute('ondragover')) {
                    this.info.push(`‚úÖ Attribut ondragover sur #${isModal ? 'modal-' : ''}column-${id}`);
                } else {
                    this.warnings.push(`‚ö†Ô∏è Attribut ondragover manquant sur #${isModal ? 'modal-' : ''}column-${id}`);
                }
            } else {
                this.errors.push(`‚ùå Colonne #column-${id} et #modal-column-${id} manquantes`);
            }
        });
        
        // V√©rifier les cartes existantes
        const cards = document.querySelectorAll('.kanban-card, .wo-kanban-card');
        this.info.push(`üìä ${cards.length} cartes Kanban trouv√©es`);
        
        cards.forEach((card, index) => {
            if (card.draggable) {
                this.info.push(`‚úÖ Carte ${index + 1} est draggable`);
            } else {
                this.warnings.push(`‚ö†Ô∏è Carte ${index + 1} n'est pas draggable`);
            }
            
            if (card.dataset.cardId) {
                this.info.push(`‚úÖ Carte ${index + 1} a un cardId: ${card.dataset.cardId}`);
            } else {
                this.errors.push(`‚ùå Carte ${index + 1} manque data-card-id`);
            }
        });
    }
    
    checkEventListeners() {
        console.log('üëÇ V√©rification des event listeners...');
        
        // Test des √©v√©nements drag
        const testCard = document.querySelector('.kanban-card');
        if (testCard) {
            // Simuler dragstart
            const dragStartEvent = new DragEvent('dragstart', {
                bubbles: true,
                cancelable: true,
                dataTransfer: new DataTransfer()
            });
            
            try {
                testCard.dispatchEvent(dragStartEvent);
                this.info.push('‚úÖ √âv√©nement dragstart peut √™tre d√©clench√©');
            } catch (error) {
                this.errors.push(`‚ùå Erreur √©v√©nement dragstart: ${error.message}`);
            }
        } else {
            this.warnings.push('‚ö†Ô∏è Aucune carte pour tester les √©v√©nements');
        }
    }
    
    checkCSRFToken() {
        console.log('üîê V√©rification du token CSRF...');
        
        const csrfMeta = document.querySelector('meta[name="csrf-token"]');
        if (csrfMeta) {
            const token = csrfMeta.getAttribute('content');
            if (token) {
                this.info.push('‚úÖ Token CSRF trouv√©');
            } else {
                this.warnings.push('‚ö†Ô∏è Token CSRF vide');
            }
        } else {
            this.warnings.push('‚ö†Ô∏è Meta tag csrf-token manquant');
        }
        
        // Tester la fonction getCSRFToken
        try {
            const token = getCSRFToken();
            this.info.push(`‚úÖ getCSRFToken() retourne: ${token ? 'token valide' : 'token vide'}`);
        } catch (error) {
            this.errors.push(`‚ùå Erreur getCSRFToken(): ${error.message}`);
        }
    }
    
    async checkAPIEndpoints() {
        console.log('üåê V√©rification des endpoints API...');
        
        try {
            // Test endpoint kanban-data
            const response = await fetch('/api/kanban-data');
            if (response.ok) {
                const data = await response.json();
                this.info.push('‚úÖ Endpoint /api/kanban-data accessible');
                this.info.push(`üìä Donn√©es: ${JSON.stringify(Object.keys(data)).slice(0, 100)}...`);
            } else {
                this.errors.push(`‚ùå Endpoint /api/kanban-data erreur: ${response.status}`);
            }
        } catch (error) {
            this.errors.push(`‚ùå Erreur r√©seau /api/kanban-data: ${error.message}`);
        }
        
        // Test endpoint de mise √† jour (r√©cup√©rer un vrai ID d'abord)
        try {
            // D'abord, r√©cup√©rer un vrai work order ID
            const kanbanResponse = await fetch('/api/kanban-data');
            if (kanbanResponse.ok) {
                const kanbanData = await kanbanResponse.json();
                const allWorkOrders = [
                    ...kanbanData.pending || [],
                    ...kanbanData.assigned || [],
                    ...kanbanData.in_progress || [],
                    ...kanbanData.completed || []
                ];
                
                if (allWorkOrders.length > 0) {
                    const testId = allWorkOrders[0].id;
                    const originalStatus = allWorkOrders[0].status;
                    
                    const response = await fetch(`/api/work-orders/${testId}/status`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCSRFToken()
                        },
                        body: JSON.stringify({status: originalStatus}) // Garde le m√™me status
                    });
                    
                    if (response.ok) {
                        this.info.push(`‚úÖ Endpoint /api/work-orders/{id}/status fonctionne (test√© avec ID ${testId})`);
                    } else {
                        this.errors.push(`‚ùå Endpoint /api/work-orders/{id}/status erreur: ${response.status}`);
                    }
                } else {
                    this.info.push('‚ÑπÔ∏è Aucun work order disponible pour tester l\'endpoint de mise √† jour');
                }
            } else {
                // Fallback: test avec un ID fictif mais ne pas traiter 404 comme erreur
                const response = await fetch('/api/work-orders/999/status', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken()
                    },
                    body: JSON.stringify({status: 'pending'})
                });
                
                // 404 est normal pour un ID inexistant, 400/401 indique un probl√®me d'auth
                if (response.status === 404) {
                    this.info.push('‚úÖ Endpoint /api/work-orders/{id}/status accessible (404 normal pour ID fictif)');
                } else if (response.status === 401 || response.status === 403) {
                    this.warnings.push('‚ö†Ô∏è Probl√®me d\'authentification API');
                } else {
                    this.warnings.push(`‚ö†Ô∏è R√©ponse inattendue: ${response.status}`);
                }
            }
        } catch (error) {
            this.errors.push(`‚ùå Erreur r√©seau API update: ${error.message}`);
        }
    }
    
    checkDragDropSetup() {
        console.log('üéØ V√©rification sp√©cifique du drag-drop...');
        
        // V√©rifier si les √©v√©nements sont attach√©s au document
        const events = ['dragstart', 'dragend', 'dragover', 'drop'];
        events.forEach(eventType => {
            // Impossible de d√©tecter directement les listeners, mais on peut tester
            this.info.push(`‚ÑπÔ∏è Test √©v√©nement ${eventType} pr√©vu`);
        });
        
        // V√©rifier les styles CSS n√©cessaires
        const styles = window.getComputedStyle(document.body);
        this.info.push('‚úÖ Styles CSS accessibles');
        
        // V√©rifier la structure des colonnes (d'abord modal, puis page)
        let kanbanSection = document.querySelector('#work-orders-kanban-board');
        if (kanbanSection) {
            this.info.push('‚úÖ Section Kanban Modal trouv√©e');
            
            const columns = kanbanSection.querySelectorAll('.wo-kanban-column');
            this.info.push(`üìä ${columns.length} colonnes dans le modal kanban`);
        } else {
            // Fallback vers section kanban classique
            kanbanSection = document.querySelector('#kanban-section');
            if (kanbanSection) {
                this.info.push('‚úÖ Section Kanban classique trouv√©e');
                
                const columns = kanbanSection.querySelectorAll('.kanban-column');
                this.info.push(`üìä ${columns.length} colonnes dans la section`);
            } else {
                this.warnings.push('‚ö†Ô∏è Aucune section kanban trouv√©e (#work-orders-kanban-board ou #kanban-section)');
            }
        }
    }
    
    displayResults() {
        console.log('üìä === R√âSULTATS DIAGNOSTIC ===');
        
        // Afficher les erreurs
        if (this.errors.length > 0) {
            console.log('üö® ERREURS CRITIQUES:');
            this.errors.forEach(error => console.log(error));
        }
        
        // Afficher les avertissements
        if (this.warnings.length > 0) {
            console.log('‚ö†Ô∏è AVERTISSEMENTS:');
            this.warnings.forEach(warning => console.log(warning));
        }
        
        // Afficher les informations
        if (this.info.length > 0) {
            console.log('‚ÑπÔ∏è INFORMATIONS:');
            this.info.forEach(info => console.log(info));
        }
        
        // R√©sum√©
        const totalIssues = this.errors.length + this.warnings.length;
        console.log(`\nüìã R√âSUM√â: ${this.errors.length} erreurs, ${this.warnings.length} avertissements, ${this.info.length} infos`);
        
        if (totalIssues === 0) {
            console.log('‚úÖ Aucun probl√®me d√©tect√© !');
        } else {
            console.log('üîß Probl√®mes d√©tect√©s - voir les d√©tails ci-dessus');
        }
        
        console.log('üîç === FIN DIAGNOSTIC ===\n');
        
        // Recommandations
        this.provideRecommendations();
    }
    
    provideRecommendations() {
        console.log('üí° === RECOMMANDATIONS ===');
        
        if (this.errors.some(e => e.includes('window.chronochat'))) {
            console.log('üîß Probl√®me d\'initialisation d√©tect√©:');
            console.log('   - V√©rifier que chronochat-dashboard.js est charg√©');
            console.log('   - Ex√©cuter: window.chronochat = new window.ChronoChatDashboard()');
        }
        
        if (this.errors.some(e => e.includes('Colonne') && e.includes('manquante'))) {
            console.log('üîß Colonnes Kanban manquantes:');
            console.log('   - V√©rifier le template HTML');
            console.log('   - S\'assurer que les IDs correspondent');
        }
        
        if (this.warnings.some(w => w.includes('draggable'))) {
            console.log('üîß Cartes non-draggable:');
            console.log('   - Recharger les donn√©es Kanban');
            console.log('   - V√©rifier createKanbanCard()');
        }
        
        console.log('üí° === FIN RECOMMANDATIONS ===');
    }
    
    // M√©thode pour tester manuellement le drag-drop
    testDragDrop() {
        console.log('üß™ Test manuel du drag-drop...');
        
        const card = document.querySelector('.kanban-card');
        const dropZone = document.querySelector('.kanban-content');
        
        if (!card || !dropZone) {
            console.log('‚ùå Impossible de tester: √©l√©ments manquants');
            return;
        }
        
        // Simuler drag-drop
        const dataTransfer = new DataTransfer();
        dataTransfer.setData('text/plain', card.dataset.cardId || 'test-id');
        
        const dragEvent = new DragEvent('dragstart', {
            bubbles: true,
            cancelable: true,
            dataTransfer: dataTransfer
        });
        
        const dropEvent = new DragEvent('drop', {
            bubbles: true,
            cancelable: true,
            dataTransfer: dataTransfer
        });
        
        try {
            card.dispatchEvent(dragEvent);
            dropZone.dispatchEvent(dropEvent);
            console.log('‚úÖ Test drag-drop ex√©cut√©');
        } catch (error) {
            console.log(`‚ùå Erreur test drag-drop: ${error.message}`);
        }
    }
}

// Fonctions utilitaires globales pour debugging
window.debugKanban = function() {
    return new KanbanDebugger();
};

window.testKanbanDragDrop = function() {
    const dbg = new KanbanDebugger();
    dbg.testDragDrop();
};

window.forceKanbanReload = function() {
    if (window.chronochat && window.chronochat.loadKanbanData) {
        console.log('üîÑ Rechargement forc√© des donn√©es Kanban...');
        window.chronochat.loadKanbanData();
    } else {
        console.log('‚ùå Impossible de recharger: window.chronochat non disponible');
    }
};

window.initKanbanManual = function() {
    console.log('üîß Initialisation manuelle du Kanban...');
    if (typeof window.ChronoChatDashboard !== 'undefined') {
        window.chronochat = new window.ChronoChatDashboard();
        console.log('‚úÖ Kanban initialis√© manuellement');
    } else {
        console.log('‚ùå Classe ChronoChatDashboard non disponible');
    }
};

console.log('üêõ Debug Kanban charg√©. Utilisez debugKanban() pour diagnostiquer.');
console.log('üìù Commandes disponibles:');
console.log('   - debugKanban() : Diagnostic complet');
console.log('   - testKanbanDragDrop() : Test manuel drag-drop');
console.log('   - forceKanbanReload() : Recharger donn√©es');
console.log('   - initKanbanManual() : Initialisation manuelle');

// Auto-diagnostic au chargement si demand√©
if (window.location.search.includes('debug=kanban')) {
    setTimeout(() => {
        console.log('üîç Auto-diagnostic activ√© via URL parameter');
        window.debugKanban();
    }, 2000);
}
